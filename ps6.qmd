---
title: "Problem Set 6 - Waze Shiny Dashboard"
author: "Sarah Morrison"
date: today
format: 
  pdf:
    include-in-header: 
       text: |
         \usepackage{fvextra}
         \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
include-before-body:
  text: |
    \RecustomVerbatimEnvironment{verbatim}{Verbatim}{
      showspaces = false,
      showtabs = false,
      breaksymbolleft={},
      breaklines
    }
---

1.  **ps6:** Due Sat 23rd at 5:00PM Central. Worth 100 points (80 points from questions, 10 points for correct submission and 10 points for code style) + 10 extra credit.

We use (`*`) to indicate a problem that we think might be time consuming.

# Steps to submit (10 points on PS6) {.unnumbered}

1.  "This submission is my work alone and complies with the 30538 integrity policy." Add your initials to indicate your agreement: \*\*SM\*\*

2.  "I have uploaded the names of anyone I worked with on the problem set [**here**](https://docs.google.com/forms/d/185usrCREQaUbvAXpWhChkjghdGgmAZXA3lPWpXLLsts/edit)" \*\*SM\*\* (2 point)

3.  Late coins used this pset: \*\*0\*\* Late coins left after submission: \*\*0\*\*

4.  Before starting the problem set, make sure to read and agree to the terms of data usage for the Waze data [here](https://canvas.uchicago.edu/courses/59054/quizzes/130617).

5.  Knit your `ps6.qmd` as a pdf document and name it `ps6.pdf`.

6.  Submit your `ps6.qmd`, `ps6.pdf`, `requirements.txt`, and all created folders (we will create three Shiny apps so you will have at least three additional folders) to the gradescope repo assignment (5 points).

7.  Submit `ps6.pdf` and also link your Github repo via Gradescope (5 points)

8.  Tag your submission in Gradescope. For the Code Style part (10 points) please tag the whole correspondingsection for the code style rubric.

*Notes: see the [Quarto documentation (link)](https://quarto.org/docs/authoring/figures.html) for directions on inserting images into your knitted document.*

*IMPORTANT: For the App portion of the PS, in case you can not arrive to the expected functional dashboard we will need to take a look at your `app.py` file. You can use the following code chunk template to "import" and print the content of that file. Please, don't forget to also tag the corresponding code chunk as part of your submission!*

```{python}
#| echo: true
#| eval: false

def print_file_contents(file_path):
    """Print contents of a file."""
    try:
        with open(file_path, 'r') as f:
            content = f.read()
            print("```python")
            print(content)
            print("```")
    except FileNotFoundError:
        print("```python")
        print(f"Error: File '{file_path}' not found")
        print("```")
    except Exception as e:
        print("```python") 
        print(f"Error reading file: {e}")
        print("```")

print_file_contents("./top_alerts_map_byhour/app.py") # Change accordingly
```

```{python}
#| echo: false

# Import required packages.
import pandas as pd
import altair as alt 
import pandas as pd
from datetime import date
import numpy as np
alt.data_transformers.disable_max_rows() 

import json
```

# Background {.unnumbered}

## Data Download and Exploration (20 points) {.unnumbered}

1.  

```{python}
waze_sample = pd.read_csv('waze_data_sample.csv')
print(waze_sample.columns)
```

```         
| Col1 | Col2 |
|-------------|
| city | Nominal |
| confidence | Quantitative |
| nThumpsUp | Quantitative |
| street | Nominal |
| uuid | Nominal |
| country | Nominal |
| type | Nominal |
| subtype | Nominal |
| roadType | Nominal |
| reliability | Ordinal |
| magvar | Quantitative |
| reportRating | Oridnal |
```

Double checked with ChatGPT

2.  

```{python}
# Read in data
waze = pd.read_csv('waze_data.csv')

```

```{python}
# create new dataframe that has the number of null and non-null values for each variable
waze_nulls = pd.DataFrame({
    'Column Name': waze.columns,
    'Null Values': waze.isnull().sum(),
    'Non-Null Values': waze.notnull().sum(),
    'Total Values': len(waze)
})

# make data long to create a nominal column for the stacked bar chart
waze_nulls_long = waze_nulls.melt(
    id_vars=['Column Name', 'Total Values'],
    value_vars=['Null Values', 'Non-Null Values'],
    var_name='Null/Non-Null',
    value_name='Count'
)

# create chart
alt.Chart(waze_nulls_long).mark_bar().encode(
  x='Column Name:N',
  y='Count:Q',
  color='Null/Non-Null:N'
)
```

```{python}
# print the columns that have null values
variables_with_nulls = waze_nulls[waze_nulls['Null Values'] > 0]['Column Name']
print("Variables with NULL values:", variables_with_nulls.tolist())

# sort variables to put the variable with the most null values up top
waze_nulls_max_values = waze_nulls['Null Values'].sort_values(ascending=False).reset_index()
waze_nulls_max_values = waze_nulls_max_values.rename(columns={'index': 'Column Name'})

# print the variable name at the top of the sorted dataframe
print("Variable with the highest share of NULL values:", waze_nulls_max_values['Column Name'].loc[0])
```

3.  

```{python}
# unique values in the 'type' column
waze['type'].unique()

# unique values in the 'subtype' column
waze['subtype'].unique()

# how many subtypes are missing for each unique type
missing_subtype_counts = waze[waze['subtype'].isna()].groupby('type').size()
print(missing_subtype_counts)

# see how many of each subtype there are
relevant_subtypes = waze.groupby('subtype').size().reset_index()

```

Even though some subtypes only appear a few times, I still think they should be included in the hierarchy. It makes more sense to include all the options available and let users decide if there are too few values to look at any charts.

Hierarchy:

-   ACCIDENT

    -   Major

    -   Minor

-   HAZARD

    -   On Road

        -   Car Stopped
        -   Construction
        -   Emergency Vehicle
        -   Ice
        -   Object
        -   Pot Hole
        -   Traffic Light Fault
        -   Lane Closed
        -   Road Kill

    -   On Shoulder

        -   Animals
        -   Car Stopped
        -   Missing Sign
        -   Weather
            -   Flood
            -   Fog
            -   Heavy Snow
            -   Hail

-   JAM

    -   Light Traffic
    -   Moderate Traffic
    -   Heavy Traffic
    -   Stand-Still Traffic

-   ROAD CLOSED

    -   Event Construction
    -   Hazard

```{python}
# fill NAs with 'Unclassified'
waze['subtype'] = waze['subtype'].fillna('Unclassified')
```

4.  
```{python}
# add type and subtype to cross walk
crosswalk = waze[['type', 'subtype']].drop_duplicates()

# update formatting for type
crosswalk['updated_type'] = crosswalk['type'].str.capitalize()
crosswalk.loc[crosswalk['type'] == 'ROAD_CLOSED', 'updated_type'] = 'Road Closed'

# entered unique subtypes to ChatGPT and asked it to create a hierarchy map
subtype_clean_mapping = {
    'ACCIDENT_MAJOR': 'Major',
    'ACCIDENT_MINOR': 'Minor',
    'HAZARD_ON_ROAD': 'On Road',
    'HAZARD_ON_ROAD_CAR_STOPPED': 'On Road',
    'HAZARD_ON_ROAD_CONSTRUCTION': 'On Road',
    'HAZARD_ON_ROAD_EMERGENCY_VEHICLE': 'On Road',
    'HAZARD_ON_ROAD_ICE': 'On Road',
    'HAZARD_ON_ROAD_OBJECT': 'On Road',
    'HAZARD_ON_ROAD_POT_HOLE': 'On Road',
    'HAZARD_ON_ROAD_TRAFFIC_LIGHT_FAULT': 'On Road',
    'HAZARD_ON_ROAD_LANE_CLOSED': 'On Road',
    'HAZARD_ON_ROAD_ROAD_KILL': 'On Road',
    'HAZARD_ON_SHOULDER': 'On Shoulder',
    'HAZARD_ON_SHOULDER_CAR_STOPPED': 'On Shoulder',
    'HAZARD_ON_SHOULDER_ANIMALS': 'On Shoulder',
    'HAZARD_ON_SHOULDER_MISSING_SIGN': 'On Shoulder',
    'HAZARD_WEATHER': 'Weather',
    'HAZARD_WEATHER_FLOOD': 'Weather',
    'HAZARD_WEATHER_FOG': 'Weather',
    'HAZARD_WEATHER_HEAVY_SNOW': 'Weather',
    'HAZARD_WEATHER_HAIL': 'Weather',
    'JAM_LIGHT_TRAFFIC': 'Light Traffic',
    'JAM_MODERATE_TRAFFIC': 'Moderate Traffic',
    'JAM_HEAVY_TRAFFIC': 'Heavy Traffic',
    'JAM_STAND_STILL_TRAFFIC': 'Stand-Still Traffic',
    'ROAD_CLOSED_EVENT': 'Event',
    'ROAD_CLOSED_CONSTRUCTION': 'Construction',
    'ROAD_CLOSED_HAZARD': 'Hazard',
}

# update subtype column
crosswalk['updated_subtype'] = waze['subtype'].replace(subtype_clean_mapping)

# create subsubtype column with none, to be updated later if necessary
crosswalk['updated_subsubtype'] = None

# update subsubtype for the required rows
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD', 
    'updated_subsubtype'] = 'General'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_CAR_STOPPED', 
    'updated_subsubtype'] = 'Car Stopped'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_CONSTRUCTION', 
    'updated_subsubtype'] = 'Construction'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_EMERGENCY_VEHICLE', 
    'updated_subsubtype'] = 'Emergency Vehicle'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_ICE',
    'updated_subsubtype'] = 'Ice'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_OBJECT', 
    'updated_subsubtype'] = 'Object'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_POT_HOLE', 
    'updated_subsubtype'] = 'Pot Hole'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_TRAFFIC_LIGHT_FAULT', 
    'updated_subsubtype'] = 'Traffic Light Fault'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_LANE_CLOSED', 
    'updated_subsubtype'] = 'Lane Closed'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_ROAD_ROAD_KILL', 
    'updated_subsubtype'] = 'Road Kill'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_SHOULDER', 
    'updated_subsubtype'] = 'General'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_SHOULDER_CAR_STOPPED', 
    'updated_subsubtype'] = 'Car Stopped'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_SHOULDER_ANIMALS', 
    'updated_subsubtype'] = 'Animals'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_ON_SHOULDER_MISSING_SIGN', 
    'updated_subsubtype'] = 'Missing Sign'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_WEATHER',
    'updated_subsubtype'] = 'General'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_WEATHER_FLOOD',
    'updated_subsubtype'] = 'Flood'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_WEATHER_FOG',
    'updated_subsubtype'] = 'Fog'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_WEATHER_HEAVY_SNOW',
    'updated_subsubtype'] = 'Heavy Snow'
crosswalk.loc[crosswalk['subtype'] == 'HAZARD_WEATHER_HAIL',
    'updated_subsubtype'] = 'Hail'
crosswalk['updated_subsubtype'] = crosswalk['updated_subsubtype'].fillna('Unclassified')

# merge crosswalk and dataframe
waze_merged = waze.merge(crosswalk, on=['type', 'subtype'], how='left')

# find how many rows there are where type = Accident and subtype = Unclassified
accident_unclassified_count = waze_merged[
    (waze_merged['updated_type'] == 'Accident') & 
    (waze_merged['updated_subtype'] == 'Unclassified')
].shape[0]
print(f"\nNumber of rows for Accident - Unclassified: {accident_unclassified_count}")

```

# App #1: Top Location by Alert Type Dashboard (30 points) {.unnumbered}

1.  

```{python}

```
<!-- -->

a.  

```{python}

```

b.  

```{python}

```

c.  

```{python}

```

d.  

```{python}

```

3.  

<!-- -->

a.  

```{python}

```

b.  

```{python}
# MODIFY ACCORDINGLY
#file_path = "./top_alerts_map/chicago-boundaries.geojson"
#----

#with open(file_path) as f:
    #chicago_geojson = json.load(f)

#geo_data = alt.Data(values=chicago_geojson["features"])

```

4.  

```{python}

```

5.  

<!-- -->

a.  

```{python}

```

b.  

```{python}

```

c.  

```{python}

```

d.  

```{python}

```

e.  

# App #2: Top Location by Alert Type and Hour Dashboard (20 points) {.unnumbered}

1.  

<!-- -->

a.  

b.  

```{python}

```

c.  

```{python}

```

2.  

<!-- -->

a.  

b.  

c.  

# App #3: Top Location by Alert Type and Hour Dashboard (20 points) {.unnumbered}

1.  

<!-- -->

a.  

b.  

```{python}

```

2.  

<!-- -->

a.  

b.  

<!-- -->

3.  

<!-- -->

a.  

b.  

c.  

d.